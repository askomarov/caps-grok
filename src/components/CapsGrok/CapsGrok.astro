---
interface Props {}

const {} = Astro.props;
---

<div class="grok-wrap mx-auto">
  <svg
    class="dynamic-svg logo"
    id="dynamic-svg"
    xmlns="http://www.w3.org/2000/svg"
    width="100%"
    preserveAspectRatio="xMidYMid meet"
    stroke-linecap="round"
  >
    <defs>
      <style>
        @import url('https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap');
        text {
          font-family: 'Oswald', sans-serif;
        }
      </style>
    </defs>
    <mask id="dynmask">
      <rect x="0" y="0" width="100%" height="100%" fill="#fff"></rect>
      <text
        id="svg-text"
        class="logo__path"
        font-family="Oswald, sans-serif"
        font-weight="black"
        text-anchor="middle"
        fill="transparent"
        stroke-width="0.15"
        stroke="red"
        dominant-baseline="middle"
      >
        CAPS
      </text>
    </mask>
    <rect
      x="0"
      y="0"
      width="100%"
      height="100%"
      mask="url(#dynmask)"
      fill="var(--bg-color)"></rect>
  </svg>
  <div class="grok-bg__gradient"></div>

  <div class="box">
    <img
      alt=""
      loading="lazy"
      width="200"
      height="200"
      src="./assets/cursor-mask.png"
    />
  </div>
  <div class="box">
    <img
      alt=""
      loading="lazy"
      width="200"
      height="200"
      src="./assets/cursor-mask.png"
    />
  </div>
  <div class="box">
    <img
      alt=""
      loading="lazy"
      width="200"
      height="200"
      src="./assets/cursor-mask.png"
    />
  </div>
</div>

<script>
  import gsap from 'gsap';

  const mouseCoords = {
    x: 0,
    y: 0
  };

  const boxData = [
    { x: 0, y: 0, lerpFactor: 0.1 },
    { x: 0, y: 0, lerpFactor: 0.05 },
    { x: 0, y: 0, lerpFactor: 0.025 }
  ];

  function lerp(start: number, end: number, t: number) {
    return start * (1 - t) + end * t;
  }

  const capsBoldColors = ['#9160e6', '#ffeb23', '#ffffff'];

  document.addEventListener('DOMContentLoaded', () => {
    const container = document.querySelector('.grok-wrap');
    const boxes = document.querySelectorAll('.box');

    if (container && boxes.length) {
      boxes.forEach((box, index) => {
        gsap.set(box, { scale: 1, xPercent: -50, yPercent: -50 });

        const xTo = gsap.quickTo(box, 'x', { duration: 0.3, ease: 'power3' });
        const yTo = gsap.quickTo(box, 'y', { duration: 0.3, ease: 'power3' });

        function handleMouseMove(e) {
          const containerRect = container.getBoundingClientRect();
          const containerWidth = containerRect.width;
          const containerHeight = containerRect.height;

          mouseCoords.x = Math.max(
            0,
            Math.min(e.clientX - containerRect.left, containerWidth)
          );
          mouseCoords.y = Math.max(
            0,
            Math.min(e.clientY - containerRect.top, containerHeight)
          );

          let t = (mouseCoords.x - containerWidth / 2) / (containerWidth / 2);
          t = Math.max(-1, Math.min(1, t));

          let colorIndex = Math.round(
            ((t + 1) / 2) * (capsBoldColors.length - 1)
          );

          boxes.forEach((boxAgain, i) => {
            let adjustedIndex = colorIndex - i;
            if (adjustedIndex < 0) {
              adjustedIndex = 0;
            }
            adjustedIndex = Math.min(adjustedIndex, capsBoldColors.length - 1);
            (boxAgain as HTMLElement).style.backgroundColor =
              capsBoldColors[adjustedIndex];
          });
        }

        window.addEventListener('mousemove', handleMouseMove);

        gsap.ticker.add(() => {
          const data = boxData[index];
          data.x = lerp(data.x, mouseCoords.x, data.lerpFactor);
          data.y = lerp(data.y, mouseCoords.y, data.lerpFactor);
          xTo(data.x);
          yTo(data.y);
        });
      });
    }

    const text = document.querySelector('#svg-text');
    const svg = document.querySelector('.dynamic-svg');

    if (svg && text) {
      const resizeSVG = () => {
        const bbox = (text as unknown as SVGGraphicsElement).getBBox();
        if (bbox.width === 0 || bbox.height === 0) return;

        const padding = 0;
        const width = bbox.width + padding;
        const height = bbox.height + padding;

        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

        text.setAttribute('x', (width / 2).toString());
        text.setAttribute('y', (height / 2).toString());
        text.setAttribute('dy', (bbox.height * 0.1).toString());
      };

      resizeSVG();
      window.addEventListener('resize', resizeSVG);

      const form = document.querySelector('#svgwordform');
      const input = document.querySelector('#svgword') as HTMLInputElement;

      if (form && input) {
        form.addEventListener('submit', (event) => {
          event.preventDefault();
          if (!input.value.trim()) return;
          text.textContent = input.value;
          resizeSVG();
          // перезапуск css анимации
          (svg.querySelector('.logo__path') as HTMLElement).style.animation = 'none';
          void (svg as HTMLElement).offsetWidth;
          setTimeout(() => {
            (svg.querySelector('.logo__path') as HTMLElement).style.animation = 'logo-path-anim 4s linear forwards';
          }, 100);
        });
      }
    }
  });
</script>
